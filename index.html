<!doctype html>
<html lang="de" data-theme="light">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<meta name="color-scheme" content="light dark">
<title>Pendler Dashboard</title>

<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="apple-mobile-web-app-title" content="Pendler Dashboard">

<link rel="apple-touch-icon" href="apple-touch-icon.png">
<link rel="icon" type="image/svg+xml" href="favicon.svg">
<link rel="alternate icon" type="image/png" sizes="512x512" href="apple-touch-icon.png">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.2/css/all.min.css">
<link rel="stylesheet" href="styles.css">
</head>
<body>

  <!-- Pull-to-Refresh indicator (hidden until pulling) -->
  <div id="ptr" class="ptr" aria-hidden="true">
    <div class="ptr-inner">
      <i id="ptrArrow" class="fa-solid fa-arrow-down-long"></i>
      <i id="ptrSpin" class="fa-solid fa-spinner fa-spin" style="display:none"></i>
      <span id="ptrLabel">Ziehen zum Aktualisieren</span>
    </div>
  </div>

  <!-- Topbar -->
  <div class="tabs">
    <button id="menuBtn" class="hamburger pressy" aria-label="Menü öffnen" aria-expanded="false">
      <i class="fa-solid fa-bars"></i> Menü
    </button>

    <div id="tabsInline" class="left" role="tablist" aria-label="Navigation">
      <a href="#route-a" class="tab pressy active">Gießen → Frankfurt(Main) Hbf</a>
      <a href="#route-b" class="tab pressy">Frankfurt(Main) Hbf → Gießen</a>
      <a href="#abfahrten" class="tab pressy">Abfahrten (stadt­einwärts)</a>
      <a href="#homebound" class="tab pressy">Abfahrten (heimwärts)</a>
      <span id="tabIndicator" class="tab-indicator"></span>
    </div>

    <div class="spacer"></div>

    <button id="themeBtn" class="theme-btn pressy" aria-label="Theme umschalten">
      <i class="fa-solid fa-sun" id="sunIcon"></i>
      <i class="fa-solid fa-moon" id="moonIcon" style="display:none"></i>
    </button>
  </div>

  <!-- Drawer -->
  <div id="drawer" class="drawer" hidden>
    <div id="drawerBackdrop" class="drawer-backdrop" role="button" aria-label="Menü schließen"></div>
    <nav class="drawer-panel" aria-label="Menü">
      <a href="#route-a" class="tab" data-drawer-link>Gießen → Frankfurt(Main) Hbf</a>
      <a href="#route-b" class="tab" data-drawer-link>Frankfurt(Main) Hbf → Gießen</a>
      <a href="#abfahrten" class="tab" data-drawer-link>Abfahrten (stadt­einwärts)</a>
      <a href="#homebound" class="tab" data-drawer-link>Abfahrten (heimwärts)</a>
      <button id="drawerClose" class="btn pressy" style="margin-top:8px"><i class="fa-solid fa-xmark"></i> Schließen</button>
    </nav>
  </div>

  <div class="wrap">

    <!-- ROUTEN -->
    <div id="view-route" hidden>
      <div id="cards" class="cards"><div class="card">Lade Verbindungen …</div></div>
      <div class="more-wrap"><button id="pinnedToggle" class="btn pressy" aria-pressed="false" title="Nur angepinnte anzeigen"><i class="fa-solid fa-thumbtack"></i> Nur angepinnte</button>
<button id="moreBtn" class="btn pressy">Weitere Verbindungen (+60 min)</button>
<span id="moreInfo" class="badge"></span>
</div>
      <div id="noJourneys" class="hint" style="display:none">Für das gewählte Zeitfenster sind keine Verbindungen verfügbar.</div>
    </div>

    <!-- ABFAHRTEN STADTEINWÄRTS -->
    <div id="view-abfahrten" class="panel-table" hidden>
      <div class="table-head">
        <div><i class="fa-solid fa-clock"></i> Abfahrt</div>
        <div class="col-plan"><i class="fa-regular fa-calendar"></i> Plan</div>
        <div><i class="fa-solid fa-train"></i> Linie</div>
        <div><i class="fa-solid fa-location-dot"></i> Ziel</div>
        <div class="col-steig"><i class="fa-solid fa-signs-post"></i> Steig</div>
        <div><i class="fa-solid fa-clock-rotate-left"></i> +-</div>
      </div>
      <div id="rows" class="rows"><div style="padding:16px;color:var(--muted)">Lade Abfahrten …</div></div>
    </div>

    <!-- ABFAHRTEN HEIMWÄRTS -->
    <div id="view-homebound" class="panel-table" hidden>
      <div class="table-head">
        <div><i class="fa-solid fa-clock"></i> Abfahrt</div>
        <div class="col-plan"><i class="fa-regular fa-calendar"></i> Plan</div>
        <div><i class="fa-solid fa-location-dot"></i> Haltestelle</div>
        <div><i class="fa-solid fa-train"></i> Linie</div>
        <div class="col-steig"><i class="fa-solid fa-signs-post"></i> Steig</div>
        <div><i class="fa-solid fa-clock-rotate-left"></i> +-</div>
      </div>
      <div id="rows-home" class="rows"><div style="padding:16px;color:var(--muted)">Lade Abfahrten …</div></div>
    </div>

    <div class="footer">
      <span id="refreshInfo">Aktualisierung: —</span>
      <span style="margin:0 8px; opacity:.6">•</span>
      <span id="lastUpdated">Zuletzt: —</span>
    </div>
    <div class="footer-space"></div>
  </div>

<script>
/* ========= Config ========= */
const API='https://v6.db.transport.rest';
const Q_SCHOOL='Sophie-Scholl-Schule Gießen', Q_FFMHBF='Frankfurt(Main) Hbf', Q_FRIEDR='Friedrichstraße Gießen', Q_GIESSEN='Gießen Bahnhof';
const REFRESH_ROUTE_MS=60000, REFRESH_DEPS_MS=30000;
const EXCLUDE_DIRECTIONS=[/rödgen/i,/coleman\s*str/i];

let ids={school:null,ffm:null,friedr:null,giessenBhf:null};
let activeTab='route-a', timer=null, lastUpdated=null;

/* Routen-Mehr */
let routeLongMode=false;
let routeWindowMin=60;

/* ========= Theme ========= */
const mediaDark=window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)');
const sunIcon=document.getElementById('sunIcon'), moonIcon=document.getElementById('moonIcon'), themeBtn=document.getElementById('themeBtn');
function applyTheme(m){
  document.documentElement.setAttribute('data-theme',m);
  if(m==='dark'){sunIcon.style.display='none';moonIcon.style.display='inline-block'}
  else {moonIcon.style.display='none';sunIcon.style.display='inline-block'}
  document.body.classList.add('theme-fade');
  setTimeout(()=>document.body.classList.remove('theme-fade'), 300);
  queueMicrotask(updateTabIndicator);
}
applyTheme(mediaDark?.matches?'dark':'light');
mediaDark?.addEventListener?.('change',e=>applyTheme(e.matches?'dark':'light'));
themeBtn.addEventListener('click',()=>applyTheme((document.documentElement.getAttribute('data-theme')==='light')?'dark':'light'));

/* ========= Drawer with subtle overshoot ========= */
const drawer=document.getElementById('drawer');
const menuBtn=document.getElementById('menuBtn');
const drawerBackdrop=document.getElementById('drawerBackdrop');
const drawerClose=document.getElementById('drawerClose');
function openDrawer(){ 
  drawer.hidden=false; 
  requestAnimationFrame(()=>{
    drawer.classList.add('open');
    const panel=drawer.querySelector('.drawer-panel');
    if(panel && !window.matchMedia('(prefers-reduced-motion: reduce)').matches){
      panel.animate(
        [{ transform:'translateX(-104%)' }, { transform:'translateX(0)' }, { transform:'translateX(-8px)' }, { transform:'translateX(0)' }],
        { duration:360, easing:'cubic-bezier(.2,.8,.2,1)' }
      );
    }
  });
  menuBtn.setAttribute('aria-expanded','true'); 
  document.body.classList.add('drawer-open');
  const h=document.querySelector('.tabs')?.offsetHeight||0; 
  const panel=drawer.querySelector('.drawer-panel');
  if(panel) panel.style.paddingTop=(h+16)+'px'; 
}
function closeDrawer(){ 
  const panel=drawer.querySelector('.drawer-panel');
  if(panel && !window.matchMedia('(prefers-reduced-motion: reduce)').matches){
    panel.animate(
      [{ transform:'translateX(0)' }, { transform:'translateX(6px)' }, { transform:'translateX(-104%)' }],
      { duration:280, easing:'cubic-bezier(.2,.8,.2,1)' }
    );
  }
  drawer.classList.remove('open'); 
  menuBtn.setAttribute('aria-expanded','false'); 
  document.body.classList.remove('drawer-open'); 
  setTimeout(()=>{ drawer.hidden=true; }, 260);
}
menuBtn.addEventListener('click', ()=> (drawer.hidden?openDrawer():closeDrawer()));
drawerBackdrop.addEventListener('click', closeDrawer);
drawerClose.addEventListener('click', closeDrawer);
drawer.addEventListener('keydown', e=>{ if(e.key==='Escape') closeDrawer(); });
drawer.querySelectorAll('[data-drawer-link]').forEach(a=>a.addEventListener('click', ()=>{ closeDrawer(); setTimeout(()=>handleHash(), 0); }));

/* ========= Motion helpers ========= */
const prefersReduced = window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches;
function animateStagger(selector){
  if(prefersReduced) return;
  const items = document.querySelectorAll(selector);
  let i=0;
  for(const el of items){
    el.animate(
      [{ opacity:0, transform:'translateY(6px) scale(0.996)' },{ opacity:1, transform:'translateY(0) scale(1)' }],
      { duration:320, easing:'cubic-bezier(.2,.8,.2,1)', delay: i*30, fill:'both' }
    );
    i++;
  }
}
/* Springy press feedback */
function addSpringyPress(root=document){
  if(prefersReduced) return;
  root.querySelectorAll('.pressy, .card, .btn').forEach(el=>{
    el.addEventListener('pointerdown', e=>{
      if(e.button!==0) return;
      el.setPointerCapture?.(e.pointerId);
      el.animate(
        [{ transform:'scale(1)' }, { transform:'scale(0.985)' }],
        { duration:90, easing:'cubic-bezier(.2,.8,.2,1)', fill:'forwards' }
      );
    });
    const up=()=>{
      el.getAnimations().forEach(a=>a.cancel());
      el.animate(
        [{ transform:'scale(0.985)' }, { transform:'scale(1.012)' }, { transform:'scale(1)' }],
        { duration:220, easing:'cubic-bezier(.2,.8,.2,1)', fill:'forwards' }
      );
    };
    el.addEventListener('pointerup', up);
    el.addEventListener('pointercancel', up);
    el.addEventListener('pointerleave', up);
  });
}
addSpringyPress();

/* ========= Dynamic Tab Underline ========= */
const tabsInline=document.getElementById('tabsInline');
const tabIndicator=document.getElementById('tabIndicator');
function updateTabIndicator(){
  if(!tabsInline || !tabIndicator) return;
  const act=tabsInline.querySelector('.tab.active');
  if(!act || getComputedStyle(tabsInline).display==='none'){
    tabIndicator.style.transform='translateX(0) scaleX(0)';
    tabIndicator.style.opacity='0';
    return;
  }
  const parentRect=tabsInline.getBoundingClientRect();
  const rect=act.getBoundingClientRect();
  const x = rect.left - parentRect.left;
  tabIndicator.style.opacity='1';
  tabIndicator.style.width = rect.width + 'px';
  tabIndicator.style.transform='translateX('+x+'px)';
}
new ResizeObserver(updateTabIndicator).observe(document.body);
window.addEventListener('resize', updateTabIndicator);
window.addEventListener('load', updateTabIndicator);

/* ========= Pull-to-Refresh (touch) ========= */
let ptrActive=false, ptrStartY=0, ptrPull=0, ptrThreshold=76, ptrDragging=false;
const ptrEl=document.getElementById('ptr'), ptrArrow=document.getElementById('ptrArrow'), ptrSpin=document.getElementById('ptrSpin'), ptrLabel=document.getElementById('ptrLabel');

function setPtrTransform(y){
  ptrEl.style.transform = 'translateY('+Math.max(0, y)+'px)';
  const rot = Math.min(1, y/ptrThreshold)*180;
  ptrArrow.style.transform = 'rotate('+rot+'deg)';
  ptrLabel.textContent = (y>=ptrThreshold?'Loslassen zum Aktualisieren':'Ziehen zum Aktualisieren');
}

function attachPullToRefresh(){
  let lastTouchY=0;
  window.addEventListener('touchstart', (e)=>{
    if(window.scrollY>0 || document.body.classList.contains('drawer-open')) return;
    ptrDragging=true;
    ptrStartY=e.touches[0].clientY;
    lastTouchY=ptrStartY;
    ptrPull=0;
    setPtrTransform(0);
    ptrEl.classList.add('show');
  }, {passive:true});

  window.addEventListener('touchmove', (e)=>{
    if(!ptrDragging) return;
    const y=e.touches[0].clientY;
    const dy=y - ptrStartY;
    if(dy>0){
      e.preventDefault();
      ptrPull = dy * 0.6; // dampen
      setPtrTransform(ptrPull);
    }else{
      // upward cancel
      ptrDragging=false;
      ptrEl.classList.remove('show');
      setPtrTransform(0);
    }
  }, {passive:false});

  function finishRefresh(){
    ptrArrow.style.display='inline-block';
    ptrSpin.style.display='none';
    ptrEl.classList.remove('refreshing');
    ptrEl.classList.remove('show');
    setPtrTransform(0);
    ptrActive=false; ptrDragging=false; ptrPull=0;
  }

  window.addEventListener('touchend', async ()=>{
    if(!ptrDragging) return;
    ptrDragging=false;
    if(ptrPull>=ptrThreshold){
      // trigger refresh for active view
      ptrActive=true;
      ptrEl.classList.add('refreshing');
      ptrArrow.style.display='none';
      ptrSpin.style.display='inline-block';
      ptrLabel.textContent='Aktualisiere …';
      try{
        if(activeTab==='abfahrten') await loadInbound();
        else if(activeTab==='homebound') await loadHomebound();
        else await loadRoute(activeTab==='route-a');
      }catch(e){ console.error(e); }
      // nice settle
      setTimeout(finishRefresh, 300);
    }else{
      // snap back
      ptrEl.classList.remove('show');
      setPtrTransform(0);
    }
  }, {passive:true});
}
attachPullToRefresh();

/* ========= Helpers ========= */
const fmtHM = d => new Date(d).toLocaleTimeString('de-DE',{hour:'2-digit',minute:'2-digit'});
const fmtHMS= d => new Date(d).toLocaleTimeString('de-DE',{hour:'2-digit',minute:'2-digit',second:'2-digit'});
function isoDurToHuman(iso,dep,arr){
  if(iso){ const h=(iso.match(/(\d+)H/)||[])[1]|0, m=(iso.match(/(\d+)M/)||[])[1]|0; return (h?`${h} h `:'')+String(m).padStart(2,'0')+' min'; }
  if(dep&&arr){ const diff=Math.max(0,Math.round((new Date(arr)-new Date(dep))/60000)); const h=Math.floor(diff/60), m=diff%60; return (h?`${h} h `:'')+String(m).padStart(2,'0')+' min'; }
  return '–';
}
function setFooter(ms){
  document.getElementById('refreshInfo').textContent='Aktualisierung: alle '+Math.round(ms/1000)+' s';
  document.getElementById('lastUpdated').textContent='Zuletzt: '+(lastUpdated?fmtHMS(lastUpdated):'—');
}
async function fetchJSON(url){
  const r=await fetch(url);
  if(!r.ok) throw new Error(`${url} → ${r.status}`);
  lastUpdated=Date.now(); setFooter((activeTab==='abfahrten'||activeTab==='homebound')?REFRESH_DEPS_MS:REFRESH_ROUTE_MS);
  return r.json();
}
async function findStopId(q,rx){
  const data=await fetchJSON(`${API}/locations?query=${encodeURIComponent(q)}&results=10&stops=true`);
  if(rx){const hit=data.find(x=>(x.type==='stop'||x.type==='station') && rx.test((x.name||'')+' '+(x.address?.city||''))); if(hit) return hit.id}
  const first=data.find(x=>x.type==='stop'||x.type==='station'); return first?.id||null;
}

/* ========= Linienfarben / Icons ========= */
const FIXED_COLORS={'Bus 1':'#3498db','1':'#3498db','Bus 17':'#e67e22','17':'#e67e22','RB40':'#9b59b6','RB41':'#1abc9c','RE30':'#f1c40f','S6':'#2ecc71','ICE':'#2c3e50','IC':'#34495e'};
const HUES=[168,145,204,282,48,28,6,210,320,260,100,36,14,190,230,75];
function hashLine(s){let h=0; for(const ch of String(s)) h=((h<<5)-h)+ch.charCodeAt(0),h|=0; return Math.abs(h)}
function lineColor(name){ if(!name) return '#7f8c8d'; const key=String(name).trim(); if(FIXED_COLORS[key]) return FIXED_COLORS[key]; const norm=key.replace(/\s+Richtung.*/i,'').trim(); if(FIXED_COLORS[norm]) return FIXED_COLORS[norm]; const hue=HUES[hashLine(key)%HUES.length]; const dark=(document.documentElement.getAttribute('data-theme')==='dark'); return `hsl(${hue} 78% ${dark?72:36}%)` }
function iconForProduct(p,m){p=(p||'').toLowerCase(); m=(m||'').toLowerCase(); if(p.includes('bus')||m==='bus')return'<i class="fa-solid fa-bus"></i>'; if(p.includes('suburban')||p.includes('s-bahn')||m==='subway')return'<i class="fa-solid fa-train-subway"></i>'; if(p.includes('tram'))return'<i class="fa-solid fa-train-tram"></i>'; return'<i class="fa-solid fa-train"></i>'}
function prettyStop(n){return n==='Gießen'?'Gießen Bahnhof':n}

/* ========= Timeline ========= */
function buildTimeline(legs){
  if(!legs?.length) return '';
  function plannedIfDiff(actual, planned){
    if(!actual || !planned) return '';
    const a=new Date(actual), p=new Date(planned);
    const diffMin=Math.round((a-p)/60000);
    return diffMin!==0 ? ` <span class="planned">(${fmtHM(planned)})</span>` : '';
  }
  const fmt=v=>v?fmtHM(v):'—';
  const cls=(a,p)=>{ if(!a||!p) return ''; const m=Math.round((new Date(a)-new Date(p))/60000); return m>0?'late':(m<0?'early':'') };
  const ico=n=> n.type==='start' ? iconForProduct(n.product,'') :
              n.type==='end'   ? '<i class="fa-solid fa-flag-checkered"></i>' :
              (!n.dep||!n.arr) ? '<i class="fa-solid fa-location-dot"></i>' :
              (/walk/i.test(n.product)?'<i class="fa-solid fa-person-walking"></i>':(/bus/i.test(n.product)?'<i class="fa-solid fa-bus"></i>':'<i class="fa-solid fa-train"></i>'));
  const sameMinute=(a,b)=>{ if(!a||!b) return false; const A=new Date(a), B=new Date(b); return A.getHours()===B.getHours() && A.getMinutes()===B.getMinutes(); };

  const nodes=[];
  nodes.push({type:'start',name:prettyStop(legs[0]?.origin?.name||'—'),dep:legs[0]?.departure||null,pdep:legs[0]?.plannedDeparture||null,product:legs[0]?.line?.product||legs[0]?.mode||''});
  for(let i=0;i<legs.length;i++){
    const l=legs[i], next=legs[i+1], dest=prettyStop(l.destination?.name||'—');
    const node={type:'mid',name:dest,arr:l.arrival||null,parr:l.plannedArrival||null,dep:null,pdep:null,product:(next?.line?.product||next?.mode||l?.line?.product||l?.mode||'')};
    if(next && next.origin?.name===l.destination?.name){ node.dep=next.departure||null; node.pdep=next.plannedDeparture||null; }
    nodes.push(node);
  }
  nodes[nodes.length-1].type='end';

  const merged=[];
  for(const n of nodes){
    const last=merged[merged.length-1];
    if(last && last.name===n.name){
      last.arr   = last.arr   || n.arr;
      last.parr  = last.parr  || n.parr;
      last.dep   = last.dep   || n.dep;
      last.pdep  = last.pdep  || n.pdep;
      last.product = last.product || n.product;
      if(n.type==='end') last.type='end';
    } else {
      merged.push({...n});
    }
  }
  const use=merged;

  return use.map(n=>{
    let right='';
    if(n.type==='start'){
      const c=cls(n.dep,n.pdep);
      right=`<span class="${c}"><span class="actual">${fmt(n.dep)}</span>${plannedIfDiff(n.dep,n.pdep)}</span>`;
    }else if(n.type==='end'){
      const c=cls(n.arr,n.parr);
      right=`<span class="${c}"><span class="actual">${fmt(n.arr)}</span>${plannedIfDiff(n.arr,n.parr)}</span>`;
    }else{
      const c1=cls(n.arr,n.parr), c2=cls(n.dep,n.pdep);
      const wait=(n.arr&&n.dep)?Math.max(0,Math.round((new Date(n.dep)-new Date(n.arr))/60000)):null;

      if(n.arr && n.dep && sameMinute(n.arr,n.dep)){
        right=`<span class="tl-meta ${c1}"><span class="actual">${fmt(n.arr)}</span>${plannedIfDiff(n.arr,n.parr)}</span>`;
      } else if(n.arr && n.dep){
        const range=
          `<span class="${c1}"><span class="actual">${fmt(n.arr)}</span>${plannedIfDiff(n.arr,n.parr)}</span>
           ▸
           <span class="${c2}"><span class="actual">${fmt(n.dep)}</span>${plannedIfDiff(n.dep,n.pdep)}</span>`;
        right=`<span class="tl-meta">${range}</span>${(wait&&wait>0)?` <span class="tl-meta">• <i class="fa-solid fa-pause"></i> ${wait}′</span>`:''}`;
      } else if(n.arr){
        right=`<span class="tl-meta ${c1}"><span class="actual">${fmt(n.arr)}</span>${plannedIfDiff(n.arr,n.parr)}</span>`;
      } else if(n.dep){
        right=`<span class="tl-meta ${c2}"><span class="actual">${fmt(n.dep)}</span>${plannedIfDiff(n.dep,n.pdep)}</span>`;
      } else {
        right=`<span class="tl-meta">—</span>`;
      }
    }
    return `<div class="tl-ico">${ico(n)}</div><div class="tl-stop">${n.name}</div><div style="text-align:right">${right}</div>`;
  }).join('');
}


/* ========= Pinning (persist, refresh, filter) ========= */
const PIN_STORE_KEY='pinnedJourneysV1';
const AUTO_UNPIN_AFTER_MS = 30*60*1000; // 30 min after arrival
let pinned = loadPinned();
let onlyPinned = false; // UI toggle: show only pinned journeys in current direction

function loadPinned(){
  try{ return JSON.parse(localStorage.getItem(PIN_STORE_KEY)||'{}')||{} }catch(e){ return {} }
}
function savePinned(){ localStorage.setItem(PIN_STORE_KEY, JSON.stringify(pinned)); }
function getDirTag(aToB){ return aToB?'A2B':'B2A'; }
function deriveKey(j){
  try{
    const legs=j?.legs||[];
    const dep=j?.departure||legs?.[0]?.departure||legs?.[0]?.plannedDeparture||'';
    const arr=j?.arrival||legs?.[legs.length-1]?.arrival||legs?.[legs.length-1]?.plannedArrival||'';
    const sig=(legs||[]).map(l=>[(l.line?.name||l.mode||''),(l.origin?.name||''),(l.destination?.name||'')].join('@')).join('|');
    const token=j?.refreshToken||j?.refreshTokenStr||'';
    return token || [dep,arr,sig].join('•');
  }catch(e){ return Math.random().toString(36).slice(2); }
}
function isPinnedKey(k){ return !!pinned[k]; }
function isPinnedJourney(j){ return isPinnedKey(deriveKey(j)); }
function pinJourney(j, aToB){
  const key=deriveKey(j);
  pinned[key]={ dir:getDirTag(aToB), token:j?.refreshToken||j?.refreshTokenStr||null, pinnedAt:Date.now(), lastData:j };
  savePinned();
  return key;
}
function unpinKey(k){ delete pinned[k]; savePinned(); }
function getArrivalTs(j){
  try{
    const legs=j?.legs||[];
    const a=j?.arrival||legs?.[legs.length-1]?.arrival||null;
    const p=j?.plannedArrival||legs?.[legs.length-1]?.plannedArrival||null;
    const use=a||p;
    return use ? new Date(use).getTime() : null;
  }catch{ return null; }
}
function cleanupPinned(){
  const now=Date.now();
  let changed=false;
  for(const [k,info] of Object.entries(pinned)){
    const j=info?.lastData;
    const ts=getArrivalTs(j);
    if(ts && now > ts + AUTO_UNPIN_AFTER_MS){
      delete pinned[k]; changed=true;
    }
  }
  if(changed) savePinned();
}
async function refreshPinned(info){
  let j=null;
  if(info?.token){
    try{
      const resp = await fetchJSON(`${API}/journeys/refresh?refreshToken=${encodeURIComponent(info.token)}&stopovers=true&language=de`);
      j = resp?.journey || resp?.journeys?.[0] || null;
    }catch(e){ /* ignore */ }
  }
  if(!j) j = info?.lastData||null;
  if(j){ info.lastData=j; }
  return j;
}
function getPinnedForDir(aToB){
  cleanupPinned();
  const tag=getDirTag(aToB);
  return Object.entries(pinned).filter(([k,info])=>info?.dir===tag);
}
async function listRefreshedPinned(aToB){
  const pins = getPinnedForDir(aToB);
  const refreshed = await Promise.all(pins.map(([k,info])=>refreshPinned(info)));
  const res=[];
  for(const j of refreshed){ if(j) res.push(j); }
  // sort by next departure
  res.sort((a,b)=>{
    const da=new Date(a?.departure||a?.legs?.[0]?.departure||a?.legs?.[0]?.plannedDeparture||0).getTime();
    const db=new Date(b?.departure||b?.legs?.[0]?.departure||b?.legs?.[0]?.plannedDeparture||0).getTime();
    return da-db;
  });
  return res;
}
async function mergePinnedJourneys(visible, aToB){
  const keys = new Set((visible||[]).map(j=>deriveKey(j)));
  const pins = await listRefreshedPinned(aToB);
  const out=[];
  for(const j of pins){
    const k=deriveKey(j);
    if(!keys.has(k)){ out.push(j); keys.add(k); }
  }
  return [...out, ...visible];
}

/* ========= Journeys Renderer ========= */
function renderJourneysInto(containerId, list, aToB){
  const wrap=document.getElementById(containerId); 
  wrap.innerHTML='';
  const journeys=list?.journeys||[];
  if(!journeys.length){
    wrap.innerHTML=`<div class="card">Keine Verbindungen gefunden.</div>`;
    return;
  }
  for(const j of journeys){
    const legs=j.legs||[]; const dep=j.departure||legs[0]?.departure; const arr=j.arrival||legs[legs.length-1]?.arrival;
    const changes=Math.max(0, legs.filter(l=>l.line).length - 1); const dur=isoDurToHuman(j.duration,dep,arr);
    let delay=0; const l0=legs.find(l=>!!l.departure); if(l0&&l0.plannedDeparture&&l0.departure) delay=Math.round((new Date(l0.departure)-new Date(l0.plannedDeparture))/60000);
    const chipDelay=(delay!==0)?`<span class="chip" style="color:${delay>0?'var(--bad)':'var(--ok)'}"><i class="fa-solid fa-clock-rotate-left"></i> ${delay>0?`+${delay}`:delay}′</span>`:'';
    const chips=legs.filter(l=>l.line).map(l=>`<span class="chip line-chip" style="--line-color:${lineColor(l.line?.name||l.mode||'')}">${iconForProduct(l.line?.product,l.mode)} ${l.line?.name||l.mode||''}</span>`).join('');

    const offsetMin = aToB ? 5 : 13;
    const leaveTime = new Date(new Date(dep).getTime() - offsetMin*60000);

    const subText = aToB ? 'Sophie-Scholl-Schule → Frankfurt(Main) Hbf'
                         : 'Frankfurt(Main) Hbf → Sophie-Scholl-Schule';

    const el=document.createElement('div'); 
    const key = deriveKey(j);
    const pinnedNow = isPinnedKey(key);
    el.className='card' + (pinnedNow?' pinned':'');
    el.dataset.key = key;
    el.dataset.dir = aToB?'A2B':'B2A';
    el.__journey = j;
let __d=(typeof delay==='number')?delay:0;
if (typeof delay==='number'){
  if (__d<=-1){ el.classList.add('is-early'); }
  else if (__d>=10){ el.classList.add('is-late-10'); }
  else if (__d>=5){ el.classList.add('is-late-5'); }
  else if (__d>=1){ el.classList.add('is-late-1'); }
}
    el.innerHTML=`
      <button class="pin-btn pressy" aria-label="${pinnedNow?'Angepinnt – entfernen':'Verbindung anheften'}" aria-pressed="${pinnedNow?'true':'false'}" title="${pinnedNow?'Angepinnt – entfernen':'Verbindung anheften'}">
        <i class="fa-solid fa-thumbtack" aria-hidden="true"></i>
      </button>

      <div class="leave-badge" title="Zeit zum Loslaufen">
        <i class="fa-solid fa-person-walking" aria-hidden="true"></i>
        <span class="leave-time">${fmtHM(leaveTime)}</span>
      </div>

      <div class="row">
        <div class="time">${fmtHM(dep)}</div>
        <div class="sep">→</div>
        <div class="time">${fmtHM(arr)}</div>
        <span class="chip"><i class="fa-regular fa-clock"></i> ${dur}</span>
        <span class="chip"><i class="fa-solid fa-right-left"></i> ${changes}</span>
        ${chipDelay}
      </div>

      <div class="row" style="gap:8px; margin-top:8px">${chips || '<span class="chip"><i class="fa-solid fa-person-walking"></i> Fußweg</span>'}</div>
      <div class="timeline">${buildTimeline(legs)}</div>
      <div class="sub">${subText}</div>
    `;
    wrap.appendChild(el);
  }
  animateStagger('#'+containerId+' .card');
  addSpringyPress(wrap);
}
    el.innerHTML=`
      <div class="leave-badge" title="Zeit zum Loslaufen">
        <i class="fa-solid fa-person-walking" aria-hidden="true"></i>
        <span class="leave-time">${fmtHM(leaveTime)}</span>
      </div>

      <div class="row">
        <div class="time">${fmtHM(dep)}</div>
        <div class="sep">→</div>
        <div class="time">${fmtHM(arr)}</div>
        <span class="chip"><i class="fa-regular fa-clock"></i> ${dur}</span>
        <span class="chip"><i class="fa-solid fa-right-left"></i> ${changes}</span>
        ${chipDelay}
      </div>

      <div class="row" style="gap:8px; margin-top:8px">${chips || '<span class="chip"><i class="fa-solid fa-person-walking"></i> Fußweg</span>'}</div>
      <div class="timeline">${buildTimeline(legs)}</div>
      <div class="sub">${subText}</div>
    `;
    wrap.appendChild(el);
  }
  animateStagger('#'+containerId+' .card');
  addSpringyPress(wrap);
}

/* ========= Departures Renderer ========= */
function normalizeDepartures(raw){ if(Array.isArray(raw)) return raw; if(raw?.departures) return raw.departures; return [] }
function deltaClass(m){ if(m>0) return 'late'; if(m<0) return 'early'; return 'ontime' }

function renderDeparturesInto(containerId, deps, mode){
  const box=document.getElementById(containerId); box.innerHTML='';
  if(!deps.length){ box.innerHTML=`<div class="hint">Keine passenden Abfahrten.</div>`; return; }
  for(const d of deps){
    const line=d.line?.name||d.line?.id||'–';
    const dir = mode==='home' ? 'Sophie-Scholl-Schule, Gießen' : prettyStop(d.direction||d.destination||'–');
    const origin = (mode==='home') ? (d.originLabel||'–') : null;
    const pl=d.platform||d.prognosedPlatform||d.plannedPlatform||'–';
    const tPl=d.plannedWhen||d.when||d.scheduledWhen, tRt=d.prognosedWhen||d.when||null;
    let deltaTxt='–', cls='ontime'; if(tPl&&tRt){ const m=Math.round((new Date(tRt)-new Date(tPl))/60000); deltaTxt=(m>0?`+${m}`:m)+'′'; cls=deltaClass(m); }
    const color=lineColor(line);
    const row=document.createElement('div'); row.className='row-item';
    row.innerHTML = (mode==='home')
      ? `
        <div>${tRt?fmtHM(tRt):(tPl?fmtHM(tPl):'–')}</div>
        <div class="col-plan">${tPl?fmtHM(tPl):'–'}</div>
        <div>${origin}</div>
        <div><span class="chip line-chip" style="--line-color:${color}">${iconForProduct(d.line?.product,d.line?.mode)} ${line}</span></div>
        <div class="col-steig">–</div>
        <div class="delta ${cls}">${deltaTxt}</div>`
      : `
        <div>${tRt?fmtHM(tRt):(tPl?fmtHM(tPl):'–')}</div>
        <div class="col-plan">${tPl?fmtHM(tPl):'–'}</div>
        <div><span class="chip line-chip" style="--line-color:${color}">${iconForProduct(d.line?.product,d.line?.mode)} ${line}</span></div>
        <div>${dir}</div>
        <div class="col-steig">${pl}</div>
        <div class="delta ${cls}">${deltaTxt}</div>`;
    box.appendChild(row);
  }
  animateStagger('#'+containerId+' .row-item');
  addSpringyPress(box);
}

/* ========= Loaders ========= */
async function ensureIds(){
  if(!ids.school)     ids.school     = await findStopId(Q_SCHOOL, /(sophie|scholl).*(gie(s|ß)en)/i);
  if(!ids.ffm)        ids.ffm        = await findStopId(Q_FFMHBF, /(frankfurt).*(hbf)/i);
  if(!ids.friedr)     ids.friedr     = await findStopId(Q_FRIEDR, /(friedrichs?tra(ß|ss)e).*(gie(s|ß)en)/i);
  if(!ids.giessenBhf) ids.giessenBhf = await findStopId(Q_GIESSEN, /(gie(s|ß)en).*(bahnhof|hbf)/i);
}

function gridCols(){ const w=window.innerWidth; if(w>=1800) return 4; if(w>=1440) return 3; if(w>=1000) return 2; return 1; }
function desiredCardsForCols(cols){ return cols===1?4:(cols===2?6:(cols===3?6:8)); }

function filterByTimeWindow(journeys, minutes){
  const now=Date.now(), limit=now+minutes*60000;
  return (journeys||[]).filter(j=>{
    const t=j.departure || j.legs?.[0]?.departure || j.legs?.[0]?.plannedDeparture;
    if(!t) return false;
    const ts=new Date(t).getTime();
    return ts>=now && ts<=limit;
  });
}

function showRouteSkeleton(count){
  const wrap=document.getElementById('cards');
  const n=Math.max(1, count|0);
  const blocks = Array.from({length:n}).map(()=>`
    <div class="card skeleton">
      <div class="s-row s-w40"></div>
      <div class="s-chip"></div>
      <div class="s-chip"></div>
      <div class="s-row s-w70"></div>
      <div class="s-timeline"></div>
    </div>`).join('');
  wrap.innerHTML = blocks;
}
function showTableSkeleton(containerId, rows){
  const box=document.getElementById(containerId);
  const n=Math.max(3, rows|0);
  box.innerHTML = Array.from({length:n}).map(()=>`
    <div class="row-item skeleton">
      <div class="s-row s-w40"></div>
      <div class="s-row s-w30"></div>
      <div class="s-row s-w60"></div>
      <div class="s-row s-w50"></div>
      <div class="s-row s-w20 hide-sm"></div>
      <div class="s-row s-w20 hide-sm"></div>
    </div>`).join('');
}

async function loadRoute(aToB=true){
  try{
    await ensureIds();
    const cols=gridCols();
    showRouteSkeleton(desiredCardsForCols(cols));

    const from=aToB?ids.school:ids.ffm, to=aToB?ids.ffm:ids.school;
    const desired=desiredCardsForCols(cols);
    const results = 80;
    const data=await fetchJSON(`${API}/journeys?from=${from}&to=${to}&results=${results}&stopovers=true&language=de`);
    const all=(data.journeys||[]).filter(j=>{
      const t=j.departure || j.legs?.[0]?.departure || j.legs?.[0]?.plannedDeparture;
      return t && new Date(t).getTime()>=Date.now();
    });

    let visible=[];
    if(!routeLongMode){
      visible = all.slice(0, desired);
      document.getElementById('noJourneys').style.display = visible.length? 'none':'block';
      document.getElementById('moreInfo').textContent = '';
    }else{
      const within=filterByTimeWindow(all, routeWindowMin);
      visible = within.length ? within : [];
      document.getElementById('noJourneys').style.display = within.length? 'none':'block';
      document.getElementById('moreInfo').textContent = within.length ? `Zeitraum: jetzt bis +${routeWindowMin} min, Treffer: ${within.length}` : `Keine Verbindungen bis +${routeWindowMin} min.`;
    }

    // Merge or show only pins
    let finalList = [];
    if(onlyPinned){
      finalList = await listRefreshedPinned(aToB);
      document.getElementById('noJourneys').style.display = finalList.length? 'none':'block';
      document.getElementById('moreInfo').textContent = finalList.length ? `Nur angepinnte: ${finalList.length}` : `Keine angepinnten Verbindungen.`;
    }else{
      finalList = await mergePinnedJourneys(visible, aToB);
    }

    renderJourneysInto('cards', {journeys: finalList}, aToB);
  }catch(e){
    document.getElementById('cards').innerHTML=`<div class="card">Fehler: ${e.message}</div>`;
  }
}

async function loadInbound(){
  try{
    await ensureIds();
    showTableSkeleton('rows', 6);
    const deps=normalizeDepartures(await fetchJSON(`${API}/stops/${ids.school}/departures?duration=120&language=de`));
    const filtered=deps.filter(d=>!EXCLUDE_DIRECTIONS.some(rx=>rx.test(String(d.direction||d.destination||''))));
    renderDeparturesInto('rows', filtered, 'in');
  }catch(e){ document.getElementById('rows').innerHTML=`<div class="hint" style="color:var(--bad)">${e.message}</div>`; }
}

async function loadHomebound(){
  try{
    await ensureIds();
    showTableSkeleton('rows-home', 6);
    const [depsBhf,depsFriedr]=await Promise.all([
      fetchJSON(`${API}/stops/${ids.giessenBhf}/departures?duration=120&language=de`),
      fetchJSON(`${API}/stops/${ids.friedr}/departures?duration=120&language=de`)
    ]);
    function pick(rows, srcLabel, rxLine){
      for(const d of normalizeDepartures(rows)){
        const lineName=d.line?.name||'';
        const dir=(d.direction||d.destination||'').toLowerCase();
        if(!rxLine.test(lineName)) continue;
        if(!/sophie.*scholl.*schule/.test(dir)) continue;
        out.push({
          originLabel:srcLabel,
          line:{name:lineName, product:d.line?.product, mode:d.line?.mode},
          when:d.when||d.prognosedWhen||d.plannedWhen,
          plannedWhen:d.plannedWhen||d.when,
          prognosedWhen:d.prognosedWhen||d.when,
          platform:d.platform||d.prognosedPlatform||d.plannedPlatform||'–'
        });
      }
    }
    const out=[];
    pick(depsBhf, 'Gießen Bahnhof', /\b(17|Bus\s*17)\b/i);
    pick(depsFriedr,'Friedrichstraße, Gießen', /\b(1|Bus\s*1)\b/i);

    out.sort((a,b)=>new Date(a.when||a.plannedWhen)-new Date(b.when||b.plannedWhen));
    const unique=[], seen=new Set();
    for(const r of out){
      const k=(r.originLabel||'')+'|'+(r.line?.name||'')+'|'+(r.when||r.plannedWhen);
      if(!seen.has(k)){ seen.add(k); unique.push(r); }
    }
    renderDeparturesInto('rows-home', unique.slice(0,30), 'home');
    if(unique.length===0){
      document.getElementById('rows-home').innerHTML=`<div class="hint">Keine passenden Abfahrten in den nächsten 120 Minuten.</div>`;
    }
  }catch(e){
    document.getElementById('rows-home').innerHTML=`<div class="hint" style="color:var(--bad)">${e.message}</div>`;
  }
}

/* ========= Tabs / Refresh ========= */
function setTabs(tab){
  activeTab=tab;
  routeLongMode=false;
  routeWindowMin=60;

  document.querySelectorAll('.tab').forEach(a=>{
    const act=a.getAttribute('href')==='#'+tab; a.classList.toggle('active',act); a.setAttribute('aria-selected',String(act));
  });
  document.getElementById('view-route').hidden=!(tab==='route-a'||tab==='route-b');
  document.getElementById('view-abfahrten').hidden=(tab!=='abfahrten');
  document.getElementById('view-homebound').hidden=(tab!=='homebound');
  updateTabIndicator();
}
function startRefresh(){
  if(timer) clearInterval(timer);
  if(activeTab==='abfahrten'){
    setFooter(REFRESH_DEPS_MS); loadInbound();  timer=setInterval(loadInbound,REFRESH_DEPS_MS);
  } else if(activeTab==='homebound'){
    setFooter(REFRESH_DEPS_MS); loadHomebound(); timer=setInterval(loadHomebound,REFRESH_DEPS_MS);
  } else {
    const aToB=(activeTab==='route-a');
    setFooter(REFRESH_ROUTE_MS); loadRoute(aToB); timer=setInterval(()=>loadRoute(aToB), REFRESH_ROUTE_MS);
  }
}
function handleHash(){
  const h=(location.hash||'#route-a').replace('#','');
  const ok=['route-a','route-b','abfahrten','homebound'];
  setTabs(ok.includes(h)?h:'route-a'); startRefresh();
}
window.addEventListener('hashchange',handleHash);
document.querySelectorAll('#tabsInline .tab').forEach(a=>a.addEventListener('click',e=>{e.preventDefault(); history.replaceState(null,'',a.getAttribute('href')); handleHash();}));

const moreBtn=document.getElementById('moreBtn');
const moreInfo=document.getElementById('moreInfo');
moreBtn.addEventListener('click', async ()=>{
  if(!(activeTab==='route-a'||activeTab==='route-b')) return;
  routeLongMode=true;
  routeWindowMin += 60;
  const aToB=(activeTab==='route-a');
  if(timer) clearInterval(timer);
  const prev=moreBtn.innerHTML; moreBtn.disabled=true; moreBtn.innerHTML='<i class="fa-solid fa-spinner fa-spin"></i> Lädt…';
  try{ await loadRoute(aToB); } finally {
    moreBtn.disabled=false; moreBtn.innerHTML=prev;
    timer=setInterval(()=>loadRoute(aToB), REFRESH_ROUTE_MS);
  }
});

// === Pin button (event delegation) ===
const cardsWrap = document.getElementById('cards');
cardsWrap.addEventListener('click', (e)=>{
  const btn = e.target.closest('.pin-btn');
  if(!btn) return;
  e.preventDefault();
  const card = btn.closest('.card');
  const key = card?.dataset?.key;
  const dirTag = card?.dataset?.dir;
  const aToBCurrent = (dirTag==='A2B') || (activeTab==='route-a');
  if(btn.getAttribute('aria-pressed')==='true'){
    unpinKey(key);
    btn.setAttribute('aria-pressed','false');
    card.classList.remove('pinned');
    // If we are in pinned-only mode, remove the card immediately
    if(onlyPinned){
      card.remove();
      if(!cardsWrap.querySelector('.card')) document.getElementById('noJourneys').style.display='block';
    }
  }else{
    const j = card.__journey;
    if(!j) return;
    pinJourney(j, aToBCurrent);
    btn.setAttribute('aria-pressed','true');
    card.classList.add('pinned');
  }
});

// === UI toggle: Only pinned ===
const pinnedToggle = document.getElementById('pinnedToggle');
pinnedToggle.addEventListener('click', async ()=>{
  const was = onlyPinned;
  onlyPinned = !onlyPinned;
  pinnedToggle.setAttribute('aria-pressed', String(onlyPinned));
  if(onlyPinned){
    pinnedToggle.innerHTML = '<i class="fa-solid fa-thumbtack"></i> Nur angepinnte';
    // Disable "more" while pinned-only is active
    moreBtn.disabled = true;
    moreInfo.textContent = 'Nur angepinnte Verbindungen';
  }else{
    moreBtn.disabled = false;
  }
  // Render current direction
  await loadRoute(activeTab==='route-a');
});


(function init(){ handleHash(); })();
window.addEventListener('resize', ()=>{
  if(activeTab==='route-a'||activeTab==='route-b') loadRoute(activeTab==='route-a');
  updateTabIndicator();
});
window.addEventListener('scroll', ()=>{
  const scrolled = (window.scrollY||document.documentElement.scrollTop) > 2;
  document.body.classList.toggle('scrolled', scrolled);
});
</script>

<!-- Mobile pull-to-refresh guard: triggers only when scrolled to top -->
<script>
(function(){
  const scroller = document.scrollingElement || document.documentElement;
  let startY = 0, pulling = false, pulled = 0;
  const THRESHOLD = 70;

  // Optional: attach an indicator element with [data-ptr] if you have one
  const indicator = document.querySelector('[data-ptr]');

  window.addEventListener('touchstart', function(e){
    // Only arm if we're at the very top
    pulling = (scroller.scrollTop <= 0);
    startY = e.touches[0].clientY;
    pulled = 0;
  }, {passive: true});

  window.addEventListener('touchmove', function(e){
    if (!pulling) return;
    const y = e.touches[0].clientY;
    pulled = Math.max(0, y - startY);
    // Only prevent default when actually pulling down from top;
    // otherwise let normal scroll happen so it doesn't "block" upward scrolling.
    if (pulled > 0) {
      e.preventDefault(); // requires {passive:false}
      if (indicator){
        indicator.style.transform = 'translateY(' + Math.min(pulled, 90) + 'px)';
        indicator.style.opacity = Math.min(1, pulled/THRESHOLD);
      }
    }
  }, {passive: false});

  window.addEventListener('touchend', function(){
    if (!pulling) return;
    if (indicator){
      indicator.style.transform = '';
      indicator.style.opacity = '';
    }
    if (pulled >= THRESHOLD){
      // Fire a custom event for your existing refresh logic to hook into.
      // If nothing handles it, fall back to a light reload.
      const handled = window.dispatchEvent(new CustomEvent('ptr-refresh'));
      if (!handled) {
        // Optional: replace with your own data-refresh function
        location.reload();
      }
    }
    pulling = false;
    pulled = 0;
  }, {passive: true});
})();
</script>

</body>
</html>
